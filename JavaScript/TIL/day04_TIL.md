### 2-2. Strict Mode (엄격 모드)
JavaScript의 Strict Mode => JavaScript 스크립트 구문의 첫 줄에 작성 or 함수의 첫 줄에 선언
JavaScript 엔진에게 내리는 일종의 명령, 코드의 문법 체크를 보다 철저히 해주는 명령이다.
느슨한 문법을 지원한 JavaScript 특성 상 엄격 모드를 이용할 것을 권장

### 2-3. 변수
#### 2-3-1. 변수와 데이터
변수는 하나의 데이터 값을 저장하거나 변경하기 위한 구성요소이다. 

**변수 선언**
- var, let, const(예약어) 중 하나를 이용하여 변수 선언 가능
  - 예약어란 개발자가 만든 단어가 아닌 소프트웨어 언어에서 만든 특수 목적을 위한 단어이다
- 변수 선언을 통해 JavaScript 엔진이 변수의 존재를 알림
- let(예약어) variableName(변수명) = value(데이터, 값)
- let 키워드로 선언된 변수에 해당하는 메모리 공간이 확보가 된다.
- 위의 변수 선언문은 변수 선언과 할당(대입)이 동시에 일어남 -> 최초로 값을 할당하는 과정을 초기화라고 부른다

**변수의 데이터는 언제든 변경될 수 있다.**

#### 2-3-2. 네이밍 규칙
식별자(변수명, 함수명, 클래스명 등)는 개발자가 지정하는 임의의 단어이지만 문법 규칙이 존재하고, 컨벤션이 존재한다.

**네이밍 규칙**
- 식별자는 문자, 숫자, 언더스코어(_), 달러 기호($)의 조합으로 작성
- 식별자는 문자, 언더스코어(_), 달러 기호($)로 시작할 수 있으며, 숫자로 시작할 수 없다.
- 식별자에는 공백이 추가될 수 없다.
- JavaScript의 예약어는 식별자로 사용할 수 없다.

**코드 컨벤션**
- 변수명은 **소문자**로 시작하는 **명사형**을 이용
- 변수명은 **소문자**로 시작하는 **명사형**을 이용
- 클래스명은 **대문자**로 시작하는 **명사**을 이용
- 두 개 이상의 단어를 결합하는 경우, 연결되는 단어의 첫 글자를 대문자로 지정 (camelCase)
- 식별자는 의미있는 단어를 사용

#### 2-3-3. 변수 선언 예약어(키워드)
**var, let, const 모두 식별자를 선언하는 예약어**

변수 선언은 주로 var, let 키워드에 의해 선언

**상수 변수 선언 const**
- 상수 변수는 초기 선언하면서 값을 대입하면 이후 값 변경이 불가
- const 로 선언된 상수는 선언과 동시에 초기값을 할당
- 상수 선언만 되고, 할당이 되지 않은 경우 에러 메시지가 출력된다.
- 컨벤션 상 모두 대문자로 표기

상수를 쓰는 이유는?
- 코드는 다수의 사람이 협업을 통해 작성하는 경우가 많기 때문에, 상수를 통해 임의로 바꾸면 안되는 값을 지정 가능하다.
- 코드 명료성을 위해 선언할 수 있다.

### 2-4. 데이터 타입
#### 2-4-1. 데이터 타입 유추
**Strong typed language vs Weakly typed language**
Strong typed language : 데이터 타입을 개발자 코드에서 선언, 선언된 데이터 타입의 데이터만 대입이 가능하며 타입과 데이터가 가하게 결합되어 있는 소프트웨어 언어
Weakly typed language : 개발자 코드에 별도로 타입을 명시하지 않아도 되는 언어(JavaScript)

JavaScript 데이터 타입은 **숫자 타입, 문자 타입, 논리 타입(boolean), 객체 타입**으로 분류

**숫자 타입**
- 숫자 타입의 데이터는 정수와 실수의 구분 없이 모두 실수로 표시

**문자 타입**
- 문자 타입의 데이터를 표기할 경우 ' ', " " 문자열을 감싸야 함
- JavaScript 엔진은 큰 따옴표, 작은 따옴표를 구분하지 않지만 문맥에 따라 구분할 필요가 있다
  - 작은 따옴표 안의 큰 따옴표는 문자열로 인식
  - 큰 따옴표 안의 작은 따옴표는 문자열로 인식

**논리 타입**
- 참/거짓 데이터를 가지는 타입
- 프로그램 코드에서 조건을 명시하는데 사용

**Template String(템플릿 문자열)**
- 동적인 데이터를 문자열 내에 삽입할 시 JavaScript는 template string 을 지원한다.
- 변수, 연산식, 함수 호출과 같은 expression code 는 대입 가능하며, statement 는 대입이 불가하다.
- 동적 데이터를 삽입하기 위해서 동적 데이터는 ${...} 로 감싸고, 해당 동적 데이터가 포함되는 문자열은 백틱(``)으로 감싼다.(작은 따옴표, 큰 따옴표 사용 불가)

**undefined vs null**

undefined
- undefined 는 타입
- 변수가 선언되었지만 해당 변수에 값이 할당되지 않은 경우 데이터 타입을 유추할 수 없는 상태의 타입

null
- 객체 타입에 대입되는 값
- 즉, null 은 객체 타입
- 객체가 선언되었지만 아직 객체에 저장된 값이 없음을 명시적으로 표현하기 위한 값
- 객체는 언제든 null 이 될 수 있지만 null 이 할당된 변수, 함수를 참조하면 에러가 발생한다.

**컬렉션 타입(array)**
- 컬렉션 타입은 **많은 유사한 특성을 가진 데이터**를 하나의 변수로 저장하여 관리하는 객체 => 배열이 가장 대표적
- 배열은 let 키워드에 의해 선언되며, 그 즉시 배열을 할당 - let array = [];
- 배열 변수의 데이터는 순서에 의해 이용되며, 이 순서는 index 로 불린다. (index 는 0부터 시작)
- 배열의 데이터 개수를 판단할 때 length 변수를 이용 - 배열명.length
- 배열의 데이터를 변경할 때 변경하고자 하는 index 로 데이터의 위치를 정하고 변경하고자 하는 데이터 대입 - 배열명[index 값] = '변경하고자 하는 데이터'
- 신규 데이터를 추가할 때 push() 함수 이용 - 배열명.push('입력하고자 하는 데이터')
  - 이는 기존에 있는 데이터 이후 순서에 추가
- 데이터를 삭제할 때 pop() 함수 이용 - 배열명.pop()
  - 배열 내에 있는 데이터를 뒤에서부터 삭제

## 3. Operator

**산술 연산자**
|연산자|설명|
|----|---|
| + | 이항 연산자, 더하기 연산|
| - | 이항 연산자, 빼기 연산|
| * | 이항 연산자, 곱하기 연산|
| / | 이항 연산자, 나누기 연산|
| % | 이항 연산자, 두 수를 나누어 나머지 값 반환|
| ++ | 단항 연산자, 데이터에 1 증가|
| -- | 단항 연산자, 데이터에 1 감소|
| ** | 이항 연산자, 거듭제곱|

**할당 연산자**
|연산자|설명|
|----|---|
| = | 할당 연산자|
| += | 더하기 할당 연산자|
| -= | 빼기 할당 연산자|
| *= | 곱하기 할당 연산자|
| /= | 나누기 할당 연산자|
| %= | 나머지 할당 연산자|

**문자 연결 연산자**
'+' 연산자는 문자열을 연결시키기 위한 연산자로도 사용 가능

**비교 연산자**
|연산자|설명|
|----|---|
| == | 값이 같으면 true |
| != | 값이 다르면 true |
| === | 값과 타입이 같으면 true |
| !== | 값 혹은 타입이 다르면 true |
| > | 좌항의 값이 우항의 값보다 크면 true |
| >= | 좌항의 값이 우항의 값보다 크거나 같으면 true |
| < | 좌항의 값이 우항의 값보다 작으면 true |
| <= | 좌항의 값이 우항의 값보다 작거나 같으면 true |

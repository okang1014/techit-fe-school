### 3-3. 스토리지 이벤트
스토리지는 storage 라는 이름의 이벤트 제공
스토리지의 데이터를 추가, 수정, 삭제하는 경우 발생하는 이벤트이며, 해당 이벤트 발생하면 콜백함수를 실행
동일 오리진의 localStorage 객체를 공유하는 페이지에서 해당 이벤트를 감지하는 경우도 존재
단 이벤트를 발생시킨 페이지에서는 storage 이벤트 실행 불가 -> 하나의 페이지 내에 iframe 으로 동일 세션에 존재하는 페이지의 경우 이벤트 감지 가능
일반 html 의 a 태그를 통해 열린 새로운 페이지는 sessionStorage 를 공유하지 않지만 window.open() 함수를 이용한 새로운 페이지는 부모창의 sessionStorage 의 정보를 복제하여 열림 -> 단, 이후에 부모창의 sessionStorage 데이터는 복제되지 않음

storage event 객체 내의 프로퍼티
key : 변경된 데이터의 키
newValue : 변경된 데이터 값
oldValue : 변경되기 이전의 데이터 값
storageArea : 변경된 스토리지 객체 확인 가능 - localStorage or sessionStorage
url : 데이터를 변경시킨 HTML 페이지의 url

## 4. WebSocket
### 4-1. HTTP 프로토콜의 특징과 한계
#### 4-1-1. HTTP 프로토콜의 특징
1. connection oriented
- 클라이언트와 서버 사이의 네트워킹을 하기 위해서는 둘 사이의 커넥션이 발생
- 즉 네트워킹을 통해 데이터를 교환하고자 하는 두 애플리케이션이 연결된 상태에서 데이터 송/수신이 이뤄진다는 것
- 클라이언트가 서버에 요청을 전달하고, 서버가 해당 요청을 처리하여 응답을 클라이언트에 전달할 수 있도록 해준다

2. stateless
- 커넥션을 맺고, 커넥션 정보를 통해 http request 를 서버에 전달, http response 를 통해 요청 처리 결과를 서버에서 클라이언트로 전달
- request 와 request 에 의한 response 가 종료되면 기존에 있는 커넥션은 종료되고, 새로운 요청이 발생하면 데이터를 주고 받기 위한 새로운 커넥션 발생
- 이는 서버의 응답을 받은 이후 자동으로 커넥션이 종료됨으로써 서버의 부하를 줄일 수 있다는 이점이 있음
- 하지만 이에 대한 단점 존재
  - 단점 1 - client 상태 유지가 프로토콜 정보 자체로는 불가함, 이는 매번 새로운 커넥션을 통해 네트워킹하기 때문에 기존의 유저 데이터를 유지할 수 없다. 이를 보완하기 위해서는 session, cookie 프로그램(백엔드 코드) 필요
  - 단점 2 - Realtime server push 구현 불가, 이는 서버의 응답을 받으면 자동으로 커넥션이 종료되기 때문에 서버에서 추가적으로 발생하는 데이터를 클라이언트에 푸시할 수 없게 됨(이러한 이유로 채팅과 같은 기능은 Http protocol 단독으로 구현 불가)

**이러한 단점들을 보완하기 위해 추가된 것이 WebSocket**
하지만 WebSocket 이 http protocol 을 완전히 대체할 수 있지 않다 => http protocol 을 사용함으로써 생기는 서버 경량화의 이점이 너무 크기 때문
http protocol 로 서버 데이터를 받을 필요가 있는 경우에만 webSocket 사용 권장

### 4-2. WebSocket
Realtime server push 를 구현할 수 없는 http protocol 의 문제를 해결하기 위해 웹에서 socket 연결을 통한 데이터 송수신을 지원하기 위한 프로토콜 ws

#### 작성 방법
브라우저에서 실행되는 앱이 webSocekt 클라이언트 프로그램, 백엔드에는 webSocekt 서버 프로그램이 별도로 만들어져야 한다

**클라이언트 프로그램**
1. 서버 연결
  - webSocket = new WebSocket("ws://localhost:300") - 새로운 WebSocket 객체 생성
  - 매개 변수에는 프로토콜명(ws)와 ws 를 통해 응답을 받을 서버의 정보 지정
  - 해당 코드에 에러가 발생하지 않는다면 서버와의 연결이 성공적임
  - 보안 프로토콜은 wss protocol
2. 데이터 송신
  - webSocket.send(`${} => ${}`)
  - JSON 데이터를 서버에 전송하겠다면 JSON.stringify() 로 JSON 문자열 전송
3. 데이터 수신
  - 서버로부터 데이터가 언제 넘어올지 모르기 때문에 이벤트 모델을 이용
  - webSocekt.onmessage = (event) => {let data = event.data}
  - 콜백 함수 내의 data 는 서버로부터 전달받은 데이터
4. 연결 해제
  - webSocket.close() 를 통해 서버와의 연결 해제

## 5. File
프론트 웹 앱에서 유저의 브라우저 파일을 사용해야 하는 경우가 존재(input, output)
파일도 일종의 데이터이므로 프론트 웹 앱과 서버 사이에서 주고 받을 수 있음
파일이 사용될 때 파일 관련 데이터(파일명, 저장시간, 파일의 내용 등) 모두 데이터로 사용가능하다

이러한 데이터를 제대로 핸들링하기 위한 이해가 필요

### 5-1. File 핸들링 제약
브라우저에서 실행되는 프론트 웹 앱에서 사용자 PC 에 저장되어 있는 파일을 핸들링하는 것은 일차적으로 브라우저에 의해 금지되어 있음
이는 웹의 개방성으로 인해 발생할 수 있는 피해를 예방하기 위함
**단, 유저가 선택한 파일에 한해서만 자바스크립트로 읽어들일 수 있고, 서버에 업로드하며, 데이터를 핸들링 할 수 있음**
이러한 파일은 html 문서 내에 <input type="file"> 을 통해 선택한 파일 또는 drag & drop 으로 웹페이지에 추가된 파일만 가능하다.

### 5-2. <input type="file">
사용자가 웹 앱에서 파일을 추가하기 위한 가장 기본적인 방법
html 문서에서 <input type="file"> 태그를 추가하면 화면에 자동으로 버튼이 생성 -> 버튼 클릭 시 파일 탐색 창이 뜨고 파일을 선택할 수 있음

**<input type="file"> 에 추가 가능한 속성**
- multiple - 사용자가 다수의 파일을 선택하여 업로드 가능
- accept - <accept="image/*">, <accept=".txt, .jpg"> 등 특정 파일 경로의 파일, 또는 특정 확장자를 가지고 있는 파일만 업로드
이렇게 선택된 파일은 File 과 Filelist 객체에 담겨서 이용 가능
File - 사용자가 선택한 파일과 파일에 대한 정보를 포함
Filelist - File 객체를 저장하는 객체

사용자가 선택한 파일 정보 획득은 대부분 <input type="file"> 에서 사용자가 파일을 선택한 순간 이루어지며, 이를 핸들링하기 위해 change 이벤트를 제공